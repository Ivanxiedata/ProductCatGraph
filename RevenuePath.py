"""
Category Weights: Each category has a "weight" associated with it, representing the importance or revenue generated by that category.
Your task is to not only find all paths but also to calculate the total weight of each path from the root to the leaf categories.
Budget Constraint: You have a maximum "budget" or limit on the total weight a path can have.
Your DFS should only return paths where the total weight does not exceed this budget.
Path Ranking: After collecting all valid paths, you will return the top 3 paths with the highest total weights.
"""
from productinfo import weights
from productinfo import input
def dfs(graph, curr_node, curr_path, all_paths, curr_cost, budget):

    # Add current node to the path
    curr_path.append(curr_node)


    if curr_cost > budget:
        curr_path.pop()
        return

    # If current node has no children, it's a leaf, so we save the current path
    if curr_node not in graph or not (graph[curr_node]):
        all_paths.append((curr_path.copy(),curr_cost))  # Copy to avoid mutability issues
    else:
        # Recur for all the children
        for child in graph[curr_node]:
            dfs(graph, child, curr_path, all_paths, curr_cost + weights[child], budget)

    # Backtrack to explore other paths
    curr_path.pop()

def ranking(all_paths):
    return sorted(all_paths, key=lambda x: x[1], reverse= True)[:3]

def revenuePath(start_category, budget):
    # All paths will be stored here
    all_paths = []
    curr_path = []

    dfs(input, start_category, curr_path,all_paths, weights[start_category], budget)
    top_3 = ranking(all_paths)
    return top_3